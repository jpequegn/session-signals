// ── Harness identification ──────────────────────────────────────────

export const HARNESS_TYPES = ["claude_code", "gemini_cli", "pi_coding_agent"] as const;
export type HarnessType = (typeof HARNESS_TYPES)[number];

// ── Normalized events ──────────────────────────────────────────────

/**
 * Canonical event types across all harnesses.
 * Each harness adapter maps its native events into these categories.
 */
export type NormalizedEventType =
  | "tool_use"
  | "tool_result"
  | "user_prompt"
  | "session_start"
  | "session_end"
  | "permission_request"
  | "permission_result"
  | "compaction";

/**
 * Harness-agnostic event format.
 * Every adapter must produce events conforming to this shape.
 */
export interface NormalizedEvent {
  /** Unique event identifier (generated by adapter if source lacks one) */
  id: string;
  /** ISO 8601 timestamp */
  timestamp: string;
  /** Which harness produced this event */
  harness: HarnessType;
  /** Canonical event type */
  type: NormalizedEventType;
  /** Session this event belongs to */
  session_id: string;
  /** Canonical tool name (normalized across harnesses, e.g. "file_edit") */
  tool_name?: string;
  /** Tool input payload (harness-specific structure) */
  tool_input?: Record<string, unknown>;
  /** Tool execution result */
  tool_result?: {
    success: boolean;
    output?: string;
    error?: string;
  };
  /** User prompt text (for user_prompt events) */
  message?: string;
  /** Whether a permission was granted or denied */
  permission_granted?: boolean;
  /** Working directory at the time of the event */
  cwd?: string;
  /** Adapter-specific metadata that doesn't fit canonical fields */
  metadata?: Record<string, unknown>;
}

// ── Friction signals ───────────────────────────────────────────────

export type FrictionSignalType =
  | "rephrase_storm"
  | "tool_failure_cascade"
  | "context_churn"
  | "permission_friction"
  | "abandon_signal"
  | "long_stall"
  | "retry_loop";

export type Severity = "high" | "medium" | "low";

export interface FrictionSignal {
  /** Signal name */
  type: FrictionSignalType;
  /** Impact level */
  severity: Severity;
  /** How many times this signal fired in the session */
  count: number;
  /** Human-readable description of what happened */
  context: string;
  /** Raw data supporting the signal */
  evidence: {
    /** Indices into the session's event stream */
    event_indices: number[];
    /** E.g. the rephrased prompts or failed commands */
    sample_data?: string;
  };
}

// ── Session facets ─────────────────────────────────────────────────

export type SessionOutcome = "completed" | "abandoned" | "errored";

export interface SessionFacets {
  /** Programming languages derived from file extensions in tool inputs */
  languages: string[];
  /** Unique canonical tool names used in the session */
  tools_used: string[];
  /** Ratio of failed tool results to total tool results (0–1) */
  tool_failure_rate: number;
  /** Session length in minutes */
  session_duration_min: number;
  /** Count of user prompt events */
  total_turns: number;
  /** How the session ended */
  outcome: SessionOutcome;
}

// ── Signal records ─────────────────────────────────────────────────

export type Scope = "pai" | `project:${string}`;

export interface SignalRecord {
  /** Session identifier */
  session_id: string;
  /** ISO 8601 timestamp of when tagging ran */
  timestamp: string;
  /** Working directory from session events */
  project: string;
  /** Routing scope derived from cwd */
  scope: Scope;
  /** Detected friction signals (may be empty) */
  signals: FrictionSignal[];
  /** Computed session facets */
  facets: SessionFacets;
}

// ── Pattern analysis (batch tier) ──────────────────────────────────

export type PatternTrend = "increasing" | "stable" | "decreasing" | "new";
export type PatternType = "recurring_friction" | "new_friction" | "regression";

export interface Pattern {
  /** Unique identifier, e.g. "pat-20260205-001" */
  id: string;
  type: PatternType;
  scope: Scope;
  description: string;
  severity: Severity;
  /** Number of sessions affected */
  frequency: number;
  trend: PatternTrend;
  root_cause_hypothesis: string;
  suggested_fix: string;
  auto_fixable: boolean;
  fix_scope: "pai" | "project";
  affected_files: string[];
}

export interface DelightPattern {
  /** What works well */
  description: string;
  /** Why it works and how to preserve it */
  insight: string;
}

export interface PatternAnalysis {
  patterns: Pattern[];
  delight_patterns: DelightPattern[];
  summary: string;
}

// ── Configuration ──────────────────────────────────────────────────

export interface TaggerConfig {
  rephrase_threshold: number;
  rephrase_similarity: number;
  tool_failure_cascade_min: number;
  context_churn_threshold: number;
  abandon_window_seconds: number;
  stall_threshold_seconds: number;
  retry_loop_min: number;
  retry_similarity: number;
}

export interface AnalyzerConfig {
  model: string;
  ollama_url: string;
  lookback_days: number;
  min_session_signals: number;
}

export interface BeadsActionConfig {
  enabled: boolean;
  min_severity: Severity;
  min_frequency: number;
  title_prefix: string;
}

export interface DigestActionConfig {
  enabled: boolean;
  output_dir: string;
}

export interface AutofixActionConfig {
  enabled: boolean;
  min_severity: Severity;
  min_frequency: number;
  branch_prefix: string;
  branch_ttl_days: number;
  allowed_tools: string[];
}

export interface ActionsConfig {
  beads: BeadsActionConfig;
  digest: DigestActionConfig;
  autofix: AutofixActionConfig;
}

export interface HarnessConfig {
  enabled: boolean;
  events_dir: string;
}

export type HarnessesConfig = Record<string, HarnessConfig>;

export interface ScopeRulesConfig {
  pai_paths: string[];
  ignore_paths: string[];
}

export interface Config {
  version: string;
  tagger: TaggerConfig;
  analyzer: AnalyzerConfig;
  actions: ActionsConfig;
  harnesses: HarnessesConfig;
  scope_rules: ScopeRulesConfig;
}
